---
title: "SQL"
description: "[Slides](sql-slides.html)"
author: "Ludovic Deneuville"
format: 
  html:
    toc: true
    toc-location: left
    toc-depth: 2
  revealjs:
    theme: moon
    footer: "[Home](../../index.html) --- [SQL](sql.html)"
    slide-number: c/t                    # collapsed/total
    slide-level: 3
    controls: true
    output-file: sql-slides.html
mermaid:
  theme: forest
code-line-numbers: false
from: markdown+emoji
---

## Structured Query Language

::: {.callout-note title="Définition"}
Le SQL est un langage standardisé utilisé pour interagir avec des bases de données relationnelles. 

Il permet de créer, manipuler, interroger et gérer les données stockées dans des tables.
:::

### Norme SQL

SQL est un language normé dont la dernière version est **SQL:2023**.

::: {.callout-caution}
Les SGBD ne respectent pas exactement la norme SQL.

À un niveau avancé d'utilisation, il y a des différences entre les SGBD.
:::

### Composantes du langage

- Définition de Données
- Manipulation de Données
- Contrôle des Transactions
- Contrôle d'accès aux Données

::: {.notes}
- Manipulation de Données
  - CRUD
- Définition de Données
  - Créer/Modifier/Supprimer une table
- Contrôle des Transactions
  - BEGIN, COMMIT, ROLLBACK
- Contrôle d'accès aux Données
  - GRANT REVOKE
:::


## Définition de Données

::: {.notes}
Ici nous n'allons travailler que sur une seule table à la fois
:::

### Créer une table

```{.sql}
CREATE TABLE joueuse (
    id_joueuse     INT,
    nom            TEXT,
    prenom         TEXT,
    date_naissance DATE,
    elo            INT,
    est_arbitre    BOOLEAN,
    code_pays      TEXT,
    taux_victoires FLOAT
);
```

::: {.notes}
C'est comme créer les colonnes d'un tableau.
:::

### CREATE avancé

```{.sql}
CREATE TABLE joueuse (
    id_joueuse     SERIAL          PRIMARY KEY,   
    nom            VARCHAR(50)     NOT NULL, 
    prenom         VARCHAR(50)     NOT NULL, 
    date_naissance DATETIME,                 
    elo            INT             CHECK (elo > 0),  
    mail           VARCHAR(100),         
    est_arbitre    BOOLEAN         DEFAULT false,
    code_pays      VARCHAR(2),          
    taux_victoires FLOAT  
);
```

### Bonnes pratiques

- Nom de table représentatif et au singulier
- Pas de majuscules, pas d'accents
- Mots séparés par des underscores (snake_case)
- Ne pas utiliser de mots clés réservés (date, user...)
- Ne pas avoir de colonne qui porte le même nom que sa table

::: {.notes}
dans les requêtes : mots clés en majuscules
:::

### Modifier une colonne

Modifier le type :

```{.sql}
ALTER TABLE joueuse
ALTER COLUMN nom TYPE VARCHAR(80);
```

<br>

Renommer :

```{.sql}
ALTER TABLE joueuse
RENAME COLUMN date_naissance TO dnais;
```

### Créer/Supprimer une colonne

Ajout :

```{.sql}
ALTER TABLE joueuse
ADD COLUMN titre VARCHAR(5);
```

<br>

Suppression :

```{.sql}
ALTER TABLE joueuse
DROP COLUMN taux_victoires;
```

### Autres possibilités

- Renommer une table
- Ajouter / Supprimer une contrainte
- Ajouter une clé étrangère
- Définir / Supprimer une valeur par défaut


### Supprimer une table

```{.sql}
DROP TABLE joueuse;
```

::: {.callout-warning}
**Cette opération est irréversible !**

 Elle supprime définitivement :
 
 - la table
 - toutes les données qu'elle contient
:::

```{.sql}
DROP TABLE IF EXISTS joueuse;      -- utile pour les scripts SQL
```


## Schéma

Utile lorsque le nombre de table devient grand.

- Organisation des objets, clarté
- Gestion des permissions


```{.sql}
CREATE SCHEMA echecs;
```

::: {.notes}
- Vente de légume
- Utiliser la même bdd pour la gestion RH, le métier et la compta
- créer un schéma pour séparer les tables
:::

### Table dans un schéma

```{.sql}
CREATE TABLE echecs.club (
    id_club          SERIAL          PRIMARY KEY,  
    nom              VARCHAR(100)    NOT NULL,   
    ville            VARCHAR(100)    NOT NULL, 
    date_creation    DATE
);
```

<br>

Déplacer la table *joueuse* dans le schéma *echecs* :

```{.sql}
ALTER TABLE joueuse SET SCHEMA echecs;
```

::: {.notes}
C'est comme créer un fichier dans un dossier.

Par défaut les objets sont créés dans le schéma `public`.
:::


## Insérer des données

```{mermaid}
classDiagram
    class Club {
        id_club PK
        nom
        ville
        date_creation
    }
```

:::::: {.fragment}
```{.sql}
INSERT INTO echecs.club 
(nom,                              ville,            date_creation)
VALUES           
('C''Chartres Echecs',            'Chartres',        '1991-09-01'),
('Bischwiller',                   'Bischwiller',     '1976-09-01'),
('Asnieres - le Grand Echiquier', 'Asnieres',        '1987-03-20'),
('Tours des Hauts-De-France',     'Saint-Quentin',   '1999-12-01');
```
::::::

:::::: {.fragment}
Pourquoi l'on n'insère pas la colonne *id_club* ? :confused:
::::::

:::{.notes}
Attention à bien mettre les virgules au bon endroit
:::

### Séquence

La colonne *id_club* est une séquence gérée par le SGBD.

Les valeurs sont générées automatiquement à l'insertion et la séquence est incrémentée (1, 2, 3...).

::: {.callout-tip title="Séquences" collapse="true"}
Il est possible de créer et gérer ses propres séquences :

```{.sql}
CREATE SEQUENCE nom_sequence START 1 INCREMENT BY 1;

SELECT currval('nom_sequence'); -- dernière valeur utilisée
SELECT nextval('nom_sequence'); -- prochaine valeur

ALTER SEQUENCE nom_sequence RESTART WITH nouvelle_valeur;

DROP SEQUENCE nom_sequence;

```
:::


:::{.notes}
- Pas de double quotes en SQL !!!
- '' : Pour ajouter un simple quote dans une chaine
:::


## Lire des données

`SELECT * FROM table` pour tout afficher.

```{.sql}
SELECT *
  FROM echecs.club;
```

<br>

:::::: {.fragment}
::: {.small-table}

| id_club |            nom                   |     ville     | date_creation |
|---------|----------------------------------|---------------|---------------|
|    1    | C'Chartres Echecs                | Chartres      | 1991-09-01    |
|    2    | Bischwiller                      | Bischwiller   | 1976-09-01    |
|    3    | Asnieres - le Grand Echiquier    | Asnieres      | 1987-03-20    |
|    4    | Tours des Hauts-De-France        | Saint-Quentin | 1999-12-01    |

:::
::::::

### Colonnes à afficher

Listez les colonnes à afficher après le `SELECT`

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse;
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Guichard               | Pauline          | 2357    |
| Daulyte-Cornette       | Deimante         | 2371    |
| Navrotescu             | Andreea          | 2338    |
| Sebag                  | Marie            | 2448    |
| Millet                 | Sophie           | 2366    |
| Skrichempko            | Almira           | 2361    |

:::
::::::

### Filter les lignes

Filtrez sur les lignes avec une clause `WHERE`.

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 WHERE elo > 2400;
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Sebag                  | Marie            | 2448    |

:::
::::::

### Plusieurs filtres

Le mot clé `AND` permet d'ajouter d'autres filtres. 

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 WHERE elo < 2400
   AND prenom LIKE 'A%';
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Navrotescu             | Andreea          | 2338    |
| Skrichempko            | Almira           | 2361    |

:::
::::::

::: {.notes}
1 seul WHERE

plusieurs AND
:::

---

Vous pouvez autoriser plusieurs conditions avec `OR`.

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 WHERE elo > 2400
    OR prenom LIKE 'A%';
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Sebag                  | Marie            | 2448    |
| Navrotescu             | Andreea          | 2338    |
| Skrichempko            | Almira           | 2361    |

:::
::::::


### LIKE

```{.sql}
SELECT *
  FROM echecs.joueuse
 WHERE prenom LIKE 'A%'         -- commence par A
    OR prenom LIKE '%A'         -- termine par A
    OR prenom LIKE '%A%'        -- contient au moins un A
    OR UPPER(prenom) LIKE '%A%' -- contient au moins un A ou un a
    OR prenom LIKE 'A__'        -- commence par A suivi de 2 autres caractères
```


- `%` : représente entre 0 et une infinité de caractères
- `_` : représente exactement 1 caractère

::: {.callout-caution}
Attention aux MAJUSCULES ≠ minuscules
:::


### Plage de valeurs

`BETWEEN` permet de spécifier une plage de valeurs numériques.

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 WHERE elo BETWEEN 2350 AND 2400;
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Guichard               | Pauline          | 2357    |
| Daulyte-Cornette       | Deimante         | 2371    |
| Millet                 | Sophie           | 2366    |
| Skrichempko            | Almira           | 2361    |

:::
::::::


### Valeurs dans une liste

Vous pouvez spécifier qu'un attribut doit appartenir à un liste avec `IN`.

Ou inversement avec `NOT IN`.

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 WHERE prenom IN ('Deimante', 'Sophie');
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Daulyte-Cornette       | Deimante         | 2371    |
| Millet                 | Sophie           | 2366    |

:::
::::::

::: {.notes}
Possible de lister des valeurs numériques
:::

### Filtre sur les attributs booléens

```{.sql}
SELECT *
  FROM echecs.joueuse
 WHERE est_arbitre IS TRUE;
```

### Filtre sur les valeurs nulles

```{.sql}
SELECT *
  FROM echecs.joueuse
 WHERE mail IS NULL; -- IS NOT NULL
```


### Ordonner le résultat

`ORDER BY` pour ordonner selon plusieurs colonnes.

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 ORDER BY elo,
          taux_victoires DESC;
```

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Navrotescu             | Andreea          | 2338    |
| Guichard               | Pauline          | 2357    |
| Skrichempko            | Almira           | 2361    |
| Millet                 | Sophie           | 2366    |
| Daulyte-Cornette       | Deimante         | 2371    |
| Sebag                  | Marie            | 2448    |

:::
::::::

### Afficher n lignes

```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 LIMIT 3;
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Guichard               | Pauline          | 2357    |
| Daulyte-Cornette       | Deimante         | 2371    |
| Navrotescu             | Andreea          | 2338    |

:::
::::::

## Mise à jour

```{.sql}
UPDATE echecs.joueuse
   SET elo = 2399
 WHERE id_joueuse = 1;
```


<br>

:::::: {.fragment}
::: {.small-table}


```{.sql}
SELECT nom,
       prenom,
       elo
  FROM echecs.joueuse
 WHERE id_joueuse = 1;
```

<br>

| **nom**                | **prenom**       | **elo** |
|------------------------|------------------|---------|
| Guichard               | Pauline          | 2399    |

:::
::::::



## Suppression



## Autres SELECT

### Type DATE

Quelques opérations avec le type `DATE`.

```{.sql}
SELECT nom,
       prenom,
       EXTRACT(YEAR FROM date_naissance) AS annee_naissance
  FROM echecs.joueuse
 WHERE date_naissance >= '1991-04-20'
    OR date_naissance BETWEEN '1991-04-20' AND '1992-12-31'
    OR EXTRACT(MONTH FROM date_naissance) = 4;
```

### Jouer avec les colonnes

```{.sql}
SELECT CONCAT(nom, ' ', prenom) AS nom_complet,
       elo
FROM echecs.joueuse;
```

<br>

:::::: {.fragment}
::: {.small-table}

| **nom_complet**                   | **elo** |
|-----------------------------------|---------|
| Guichard         Pauline          | 2357    |
| Daulyte-Cornette Deimante         | 2371    |
| Navrotescu       Andreea          | 2338    |
| Sebag            Marie            | 2448    |
| Millet           Sophie           | 2366    |
| Skrichempko      Almira           | 2361    |

:::
::::::







